---
phase: 01-foundation-api-route
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - src/app/api/generate/route.ts
autonomous: true
requirements:
  - INFRA-01
  - INFRA-02
  - INFRA-03
  - INFRA-04

must_haves:
  truths:
    - "POST with valid prompt returns binary image data (Content-Type: image/png)"
    - "POST with empty or missing prompt returns 400 with 'Please enter a prompt.'"
    - "POST with malformed JSON body returns 400 with 'Invalid request body.'"
    - "Safety-filtered prompt returns 422 with clear safety message"
    - "Long-running request that exceeds timeout returns 504 with timeout message"
    - "API key is only used server-side in the route handler"
  artifacts:
    - path: "src/app/api/generate/route.ts"
      provides: "Complete Gemini API proxy with validation, safety detection, timeout, binary response"
      exports: ["POST", "maxDuration"]
      min_lines: 80
  key_links:
    - from: "src/app/api/generate/route.ts"
      to: "src/lib/gemini.ts"
      via: "import { ai, MODEL_ID }"
      pattern: "import.*\\{.*ai.*MODEL_ID.*\\}.*gemini"
    - from: "src/app/api/generate/route.ts"
      to: "src/lib/schemas.ts"
      via: "import { generateRequestSchema }"
      pattern: "import.*generateRequestSchema.*schemas"
    - from: "src/app/api/generate/route.ts"
      to: "Gemini API"
      via: "ai.models.generateContent() network call"
      pattern: "ai\\.models\\.generateContent"
---

<objective>
Implement the core API route handler that proxies image generation requests to Google Gemini 3 Pro Image with full validation, safety filter detection, timeout handling, and binary image response.

Purpose: This is the single most critical deliverable of Phase 1 -- the route handler that every downstream phase depends on. It must handle all error cases correctly from day one because retrofitting error handling is harder than building it in.
Output: A working POST endpoint at `/api/generate` that accepts generation requests and returns either a binary image or a structured JSON error.
</objective>

<execution_context>
@/Users/nusretozturk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nusretozturk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-api-route/01-RESEARCH.md
@.planning/phases/01-foundation-api-route/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement POST route handler with complete error handling</name>
  <files>src/app/api/generate/route.ts</files>
  <action>
    Create `src/app/api/generate/route.ts` implementing the complete Gemini proxy. This is a Dual Response Strategy: binary for success, JSON for errors.

    **Structure (in order):**

    1. **Imports and config:**
       - Import `NextRequest` from `next/server`
       - Import `{ ai, MODEL_ID }` from `@/lib/gemini`
       - Import `{ generateRequestSchema }` from `@/lib/schemas`
       - Import `{ ERROR_MESSAGES, GEMINI_TIMEOUT_MS }` from `@/lib/constants`
       - Export `const maxDuration = 120` (Vercel timeout safety -- INFRA-04)

    2. **Request body parsing:**
       - Wrap `req.json()` in try/catch. If JSON parsing fails, return 400 with `ERROR_MESSAGES.INVALID_BODY`

    3. **Zod validation:**
       - `generateRequestSchema.safeParse(body)`. If fails, return 400 with `parsed.error.errors[0].message` (INFRA-02)
       - Destructure: `{ prompt, mode, aspectRatio, resolution, image, imageMimeType }`

    4. **Build Gemini request:**
       - Create `parts` array starting with `{ text: prompt }`
       - If `mode === "image-to-image"` and image + imageMimeType exist, add `{ inlineData: { data: base64Data, mimeType: imageMimeType } }`. Strip data URL prefix if present (check for comma, split on comma, take second part).

    5. **Call Gemini with timeout (INFRA-04):**
       - Use `Promise.race()` pattern with a timeout promise set to `GEMINI_TIMEOUT_MS` (115 seconds). This is more portable than AbortController (SDK may not support AbortSignal directly -- see research open question #2).
       - Timeout promise rejects with a custom error identifiable by a `name` or `message` property (e.g., `new Error("TIMEOUT")`).
       - Call `ai.models.generateContent()` with:
         - `model: MODEL_ID`
         - `contents: [{ role: "user", parts }]`
         - `config: { responseModalities: ["TEXT", "IMAGE"], imageConfig: { aspectRatio, imageSize: resolution } }`
       - CRITICAL: `responseModalities` must be uppercase `["TEXT", "IMAGE"]` and `imageSize` values must be uppercase `"1K"`, `"2K"`, `"4K"` (research pitfall #5).

    6. **Safety filter detection (INFRA-03):**
       Three checks, in order:
       a. `response.promptFeedback?.blockReason` -- prompt was blocked before generation. Return 422 with `ERROR_MESSAGES.SAFETY_BLOCKED`.
       b. `candidate.finishReason === "SAFETY"` -- generation blocked. Return 422 with `ERROR_MESSAGES.SAFETY_BLOCKED`.
       c. No `inlineData` in any part -- image was not generated (silent failure). Return 422 with `ERROR_MESSAGES.SAFETY_BLOCKED`.

    7. **Extract image and text from response parts:**
       - Iterate `candidate.content?.parts ?? []`
       - If `part.inlineData?.data` exists, capture as `imageData` and `mimeType`
       - If `part.text` exists, capture as `textResponse`

    8. **Return binary image response:**
       - Convert base64 to binary: `Buffer.from(imageData, "base64")`
       - Return `new Response(binaryData, { status: 200, headers: { "Content-Type": mimeType, "Content-Length": binaryData.length.toString(), "X-Text-Response": textResponse ? encodeURIComponent(textResponse) : "", "Cache-Control": "no-store" } })`

    9. **Error catch block:**
       - If error message is "TIMEOUT", return 504 with `ERROR_MESSAGES.TIMEOUT` (INFRA-04)
       - For all other errors, `console.error("Gemini API error:", error)` and return 502 with `ERROR_MESSAGES.GENERATION_FAILED`

    **Do NOT:**
    - Export GET, PUT, DELETE, or any other methods. Next.js returns 405 automatically for undefined methods.
    - Use `NEXT_PUBLIC_` for the API key.
    - Use Server Actions (wrong pattern for long-running operations).
    - Return JSON for successful image responses (will break at 2K/4K on Vercel due to 4.5 MB limit).
  </action>
  <verify>
    1. Run `npm run build` -- route must compile without TypeScript errors.
    2. Run `npm run dev` and test with curl:
       - Valid request: `curl -X POST http://localhost:3000/api/generate -H "Content-Type: application/json" -d '{"prompt":"a red apple on a white table"}' --output test.png` -- should save a valid PNG file.
       - Empty prompt: `curl -X POST http://localhost:3000/api/generate -H "Content-Type: application/json" -d '{"prompt":""}'` -- should return 400 JSON with "Please enter a prompt."
       - Malformed body: `curl -X POST http://localhost:3000/api/generate -H "Content-Type: application/json" -d 'not json'` -- should return 400 JSON with "Invalid request body."
       - Wrong method: `curl -X GET http://localhost:3000/api/generate` -- should return 405.
    3. Verify route file imports from `@/lib/gemini` and `@/lib/schemas` (not direct SDK usage).
  </verify>
  <done>
    Route handler exists at src/app/api/generate/route.ts. Exports POST and maxDuration. Valid prompt returns binary PNG. Empty prompt returns 400 JSON. Malformed body returns 400 JSON. Safety-filtered content returns 422 JSON. Timeout returns 504 JSON. API key never appears in client code.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds with the route handler
2. POST with valid prompt returns Content-Type: image/png and binary data
3. POST with empty prompt returns `{"error":"Please enter a prompt."}` with status 400
4. POST with `not json` body returns `{"error":"Invalid request body."}` with status 400
5. POST with invalid aspect ratio returns `{"error":"Invalid aspect ratio."}` with status 400
6. GET request returns 405
7. `grep -r "GEMINI_API_KEY" src/` shows only server-side usage in lib/gemini.ts
8. `grep -r "NEXT_PUBLIC" src/` returns nothing
</verification>

<success_criteria>
- API route compiles and handles all request paths (valid, invalid, safety, timeout)
- Binary response pattern used for successful image generation (bypasses Vercel 4.5 MB limit)
- JSON error responses with specific messages matching PRD error table
- Safety filter detection covers all 3 signals (promptFeedback, finishReason, missing inlineData)
- Timeout at 115s with clear error message
- Only POST method exported
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-api-route/01-02-SUMMARY.md`
</output>
